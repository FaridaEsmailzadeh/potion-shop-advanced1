<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Magic Potion Shop — Advanced</title>
</head>
<body>
<script>
// ========== Magic Potion Shop — Advanced ==========

// ---------- Helpers ----------
const sanitize = (s) => (s ?? "").toString().trim();
const askYesNo = (q) => sanitize(prompt(q)).toLowerCase().startsWith("y");
const askNumber = (q, def = 0) => {
  const n = Number(sanitize(prompt(q)));
  return Number.isFinite(n) && n >= 0 ? n : def;
};

// ---------- 1) Start the Game ----------
let playerName = sanitize(prompt("What's your name?"));
let playerAge  = askNumber("How old are you?", 16);
let favElement = sanitize(prompt("Favorite element? (fire, water, earth, air)")).toLowerCase();

const ageMsg = playerAge >= 18 ? "a seasoned apprentice" : "a bright young apprentice";
alert(`Welcome ${playerName || "Adventurer"}! At ${playerAge}, you're ${ageMsg} of ${favElement || "mystic elements"}!`);

// ---------- 2) Stock Setup ----------
const potions = ["Healing Potion","Mana Elixir","Invisibility Draft","Fire Resistance"];

const potionStock = {
  "Healing Potion":      { quantity: 5, price: 10 },
  "Mana Elixir":         { quantity: 3, price: 15 },
  "Invisibility Draft":  { quantity: 2, price: 25 },
  "Fire Resistance":     { quantity: 4, price: 20 },
};

let gold = 0;
let customersServed = 0;
let potionsBrewed = 0;

// Nicely formatted menu using .map()
function buildMenu() {
  return potions.map(p => {
    const { quantity, price } = potionStock[p];
    return `• ${p} — Qty: ${quantity} | Price: ${price}g`;
  }).join("\n");
}

function showMenuAlert(title = "Available Potions") {
  alert(`${title}:\n\n${buildMenu()}`);
}

// ---------- Magic Book (functions in an object) ----------
const magicBook = {
  // simple flavor spells that affect nothing but give fun feedback
  ignite: (target = "cauldron") => `You whisper 'Ignis' — the ${target} crackles to life!`,
  cleanse: () => "You chant 'Puritas' — your tools gleam like new!",
  fortune: () => "You draw a rune — luck hums in the air. Today feels profitable!",
  // a functional helper: price modifier spell (demonstrates functions in objects)
  haggle(price) { // 5g discount but not below 1
    return Math.max(1, price - 5);
  }
};

// Optional: a quick spell at start using ternary + magicBook
const warmUp = askYesNo("Cast a warm-up spell? (yes/no)");
if (warmUp) {
  const spell = sanitize(prompt("Choose a spell: ignite / cleanse / fortune / haggle"));
  switch (spell.toLowerCase()) {
    case "ignite":  alert(magicBook.ignite()); break;
    case "cleanse": alert(magicBook.cleanse()); break;
    case "fortune": alert(magicBook.fortune()); break;
    case "haggle":  alert("Haggle prepared: next sale uses a discount spell!"); break;
    default: alert("The spell fizzles. Maybe read the book again!");
  }
}

// ---------- 3) Customer Orders (switch/if + loops) ----------
showMenuAlert();

let haggleReady = false; // becomes true if user picked "haggle" spell above
if (warmUp) haggleReady = true;

for (let i = 0; i < 3; i++) {
  if (!askYesNo("A customer is here! Take their order? (yes/no)")) {
    alert("You let the customer wander off...");
    continue;
  }

  const choice = sanitize(prompt("Which potion do they want?\n\n" + buildMenu()));
  if (!potionStock.hasOwnProperty(choice)) {
    alert("We don't carry that potion.");
    continue;
  }

  const stock = potionStock[choice];
  if (stock.quantity <= 0) {
    alert(`${choice} is out of stock!`);
    continue;
  }

  // Optional haggle: apply once on the next sale
  let salePrice = stock.price;
  if (haggleReady) {
    salePrice = magicBook.haggle(salePrice);
    haggleReady = false;
    alert(`Haggle spell active! New price for this sale: ${salePrice}g`);
  }

  // ask quantity (supports buying multiple)
  const qty = Math.min(askNumber(`How many ${choice}?\n(Available: ${stock.quantity})`, 1), stock.quantity);
  if (qty <= 0) { alert("Sale canceled."); continue; }

  stock.quantity -= qty;
  gold += salePrice * qty;
  customersServed++;
  alert(`Sold ${qty} × ${choice} for ${salePrice * qty} gold.`);
}

// ---------- 4) Brewing Potions (function + loops + sanitization) ----------
function brewPotion(potionName, amount) {
  potionName = sanitize(potionName);
  amount = Number(amount);
  if (!potionStock[potionName]) {
    alert("That potion doesn't exist.");
    return false;
  }
  if (!Number.isFinite(amount) || amount <= 0) {
    alert("Amount must be a positive number.");
    return false;
  }
  potionStock[potionName].quantity += amount;
  potionsBrewed += amount;
  alert(`You brewed ${amount} × ${potionName}!`);
  return true;
}

// allow 2–3 brew rounds
const brewRounds = 2 + (favElement === "water" ? 1 : 0); // tiny customization via ternary
for (let i = 0; i < brewRounds; i++) {
  if (!askYesNo("Do you want to brew more potions? (yes/no)")) break;
  const name = sanitize(prompt("Which potion to brew?\n\n" + buildMenu()));
  const amt  = askNumber("How many to brew?", 1);
  brewPotion(name, amt);
  showMenuAlert("Updated Stock");
}

// ---------- 5) Timered End-of-Day Report ----------
const WORKDAY_MS = 30000; // 30 ثانیه برای دموی سریع (می‌توانی بیشترش کنی)
alert(`The magical clock starts now. Your workday ends in ${WORKDAY_MS/1000} seconds...`);

setTimeout(() => {
  // compute totals with destructuring
  let totalLeft = 0;
  for (const [name, {quantity}] of Object.entries(potionStock)) {
    totalLeft += quantity;
  }

  const summaryLines = Object.entries(potionStock)
    .map(([name, {quantity, price}]) => `• ${name}: ${quantity} left (price ${price}g)`)
    .join("\n");

  alert(
    `Great job, ${playerName || "Apprentice"}!\n` +
    `You brewed ${potionsBrewed} potions and helped ${customersServed} customer(s) today.\n` +
    `Gold earned: ${gold}\n\n` +
    `Stock at closing:\n${summaryLines}\n\n` +
    `Total bottles left: ${totalLeft}`
  );
}, WORKDAY_MS);

</script>
</body>
</html>
